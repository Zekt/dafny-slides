\documentclass[10pt, compress]{beamer}

\usetheme{m}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{verbatimbox}

\title{Introduction to Dafny}
\subtitle{}
\date{\today}
\author{Lin Tzu-Chi}

\begin{document}

\maketitle

\begin{frame}[fragile]
  \frametitle{Dafny}

  Dafny is a imperative programming language with built-in annotations to prove correctness of code.
  
\end{frame}

\section{Basic Syntax}

\begin{frame}[fragile]
  \frametitle{Methods}
  
  \verb|method|s are functions in typical imperative languages.
  
  \begin{verbnobox}[\footnotesize]
  method Abs(x: int) returns (y: int)
  {
    if x < 0
      { return -x; }
    else
      { return x; }
  }
  \end{verbnobox}
  The input parameters are read only, and an implicit \verb|return| is added automatically at the end of a method, where the current values of return parameters are returned as-is.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Methods}
  
  There can be multiple return values.
  \begin{verbnobox}[\footnotesize]
method MultipleReturns(x: int, y: int)
returns (more: int, less: int)
{
  more := x + y;
  less := x - y;
  // comments.
}
  \end{verbnobox}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pre- and Postconditions}
  \verb|ensures| annotates postconditions of a method for Dafny to check its correctness. 
  \begin{verbnobox}[\footnotesize]
method MultipleReturns(x: int, y: int)
returns (more: int, less: int)
  ensures less < x
  ensures x < more
{
    more := x + y;
    less := x - y;
}
  \end{verbnobox}	
  
Dafny rejects this program.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pre- and Postconditions}
  \verb|requires| annotates preconditions. It is the programmer's job to establish them.
  \begin{verbnobox}[\footnotesize]
method MultipleReturns(x: int, y: int)
returns (more: int, less: int)
   requires 0 < y
   ensures less < x < more
{
   more := x + y;
   less := x - y;
}

  \end{verbnobox}
  Dafny verifies this program successfully.

\end{frame}

\begin{frame}[fragile]
  \frametitle{Assertions}
  \verb|assert| is a keyword to place assertions in the moddle of a method.
  \begin{verbnobox}[\footnotesize]
// use definition of Abs() from before.
method Testing()
{
   var v := Abs(3);
   assert 0 <= v;
}
  \end{verbnobox}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Assertions}

  The program:
  \begin{verbnobox}[\footnotesize]
var v := Abs(3);
assert v == 3;
  \end{verbnobox}
  would not be verified, because Dafny only knows the postconditions of \verb|Abs|, but nothing more.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Assertions}
  To prove the assertion above, we can modify \verb|Abs| to provide more information.
  \begin{verbnobox}[\footnotesize]
method Abs(x: int) returns (y: int)
   ensures 0 <= y
   ensures 0 <= x ==> x == y
{
   // body as before
}
  \end{verbnobox}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions}
  \begin{verbnobox}[\footnotesize]
function abs(x: int): int
{
   if x < 0 then -x else x
}
  \end{verbnobox}[\footnotesize]
  Unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct return type.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions}
The power of functions comes from the fact that they can be used directly in specifications. So we can write:
  \begin{verbnobox}[\footnotesize]
assert abs(3) == 3;
  \end{verbnobox}
without explicitly writing pre- and postconditions.

\end{frame}

\begin{frame}[fragile]{Loop Invariants}

  \begin{verbnobox}[\footnotesize]
var i := 0;
while i < n
   invariant 0 <= i
{
   i := i + 1;
}
  \end{verbnobox}
When you specify an invariant, Dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop.
Assuming the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again.
\end{frame}

\begin{frame}[fragile]{Loop Invariants}
  \begin{verbnobox}[\footnotesize]
method ComputeFib(n: nat) returns (b: nat)
   ensures b == fib(n)
{
   if n == 0 { return 0; }
   var i: int := 1;
   var a := 0;
       b := 1;
   while i < n
      invariant 0 < i <= n
      invariant a == fib(i - 1)
      invariant b == fib(i)
   {
      a, b := b, a + b;
      i := i + 1;
   }
}
  \end{verbnobox}
\end{frame}

\begin{frame}[fragile]{Termination}
A decreases annotation, as its name suggests, gives Dafny and expression that decreases with every loop iteration or recursive call.
  \begin{verbnobox}[\footnotesize]
while 0 < i
   invariant 0 <= i
   decreases i
{
   i := i - 1;
}
  \end{verbnobox}
\end{frame}

\begin{frame}[fragile]{Arrays}
  \verb|array<T>| is the type of array of \verb|T|. Arrays can be \verb|null|, and have a built in length field, \verb|a.Length|.
  All array accesses must be proven to be within bounds.
  This program can be successfully verified:
  \begin{verbnobox}[\footnotesize]
method Find(a: array<int>, key: int) returns (index: int)
   ensures 0 <= index ==> index < a.Length && a[index] == key
{
  return -1;
}
  \end{verbnobox}
\end{frame}

\begin{frame}[fragile]{Quantifiers}
  \begin{verbnobox}[\scriptsize]
method Find(a: array<int>, key: int) returns (index: int)
   ensures 0 <= index ==> index < a.Length && a[index] == key
   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key
{
   index := 0;
   while index < a.Length
      invariant 0 <= index <= a.Length
      invariant forall k :: 0 <= k < index ==> a[k] != key
   {
      if a[index] == key { return; }
      index := index + 1;
   }
   index := -1;
}
  \end{verbnobox}
\end{frame}

\begin{frame}[fragile]{Predicates}
  A predicate is a function which returns a boolean. 
  \begin{verbnobox}[\footnotesize]
predicate sorted(a: array<int>)
   requires a != null
{
   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]
}
  \end{verbnobox}
Note that there is no return type, because predicates always return a boolean.
Dafny rejects this code as given, claiming that the predicate cannot read a. Fixing this issue requires another annotation, the reads annotation.
\end{frame}

\begin{frame}[fragile]{Framing}
  The sorted predicate is not able to access the array because the array was not included in the function's reading frame. The reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. 
  Dafny will check that you do not read any memory location that is not stated in the reading frame.
  \begin{verbnobox}[\footnotesize]
predicate sorted(a: array<int>)
   requires a != null
   reads a
{
   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]
}
  \end{verbnobox}
\end{frame}

\begin{frame}[fragile]{Binary Search}
  \begin{verbnobox}[\tiny]
predicate sorted(a: array<int>)
   requires a != null
   reads a
{
   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]
}
method BinarySearch(a: array<int>, value: int) returns (index: int)
   requires a != null && 0 <= a.Length && sorted(a)
   ensures 0 <= index ==> index < a.Length && a[index] == value
   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value
{
   var low, high := 0, a.Length;
   while low < high
      invariant 0 <= low <= high <= a.Length
      invariant forall i ::
         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value
   {
      var mid := (low + high) / 2;
      if a[mid] < value
      {
         low := mid + 1;
      }
      else if value < a[mid]
      {
         high := mid;
      }
      else
      {
         return mid;
      }
   }
   return -1;
}
  \end{verbnobox}
\end{frame}


\end{document}
